{"version":3,"sources":["../src/ReactCompareSlider.tsx","../src/Container.tsx","../src/ReactCompareSliderHandle.tsx","../src/utils.ts","../src/ReactCompareSliderImage.tsx","../src/useReactCompareSliderRef.ts"],"sourcesContent":["import React, {\n  forwardRef,\n  useCallback,\n  useEffect,\n  useImperativeHandle,\n  useRef,\n  useState,\n} from 'react';\nimport type { CSSProperties, ReactElement } from 'react';\n\nimport { ContainerClip, ContainerHandle } from './Container';\nimport { ReactCompareSliderHandle } from './ReactCompareSliderHandle';\nimport type { ReactCompareSliderDetailedProps, UseReactCompareSliderRefReturn } from './types';\nimport type { UseResizeObserverHandlerProps } from './utils';\nimport { usePrevious } from './utils';\nimport { KeyboardEventKeys, useEventListener, useResizeObserver } from './utils';\n\n/** Properties for internal `updateInternalPosition` callback. */\ninterface UpdateInternalPositionProps {\n  /** X coordinate to update to (landscape). */\n  x: number;\n  /** Y coordinate to update to (portrait). */\n  y: number;\n  /** Whether to calculate using page X and Y offsets (required for pointer events). */\n  isOffset?: boolean;\n}\n\nconst EVENT_PASSIVE_PARAMS = { capture: false, passive: true };\nconst EVENT_CAPTURE_PARAMS = { capture: true, passive: false };\n\n/** Root Comparison slider. */\nexport const ReactCompareSlider = forwardRef<\n  UseReactCompareSliderRefReturn,\n  ReactCompareSliderDetailedProps\n>(\n  (\n    {\n      disabled = false,\n      handle,\n      itemOne,\n      itemTwo,\n      onlyHandleDraggable = false,\n      onPositionChange,\n      portrait = false,\n      position = 50,\n      boundsPadding = 0,\n      changePositionOnHover = false,\n      keyboardIncrement = '5%',\n      style,\n      transition,\n      ...props\n    },\n    ref,\n  ): ReactElement => {\n    /** DOM node of the root element. */\n    const rootContainerRef = useRef<HTMLDivElement>(null);\n    /** DOM node of the item that is clipped. */\n    const clipContainerRef = useRef<HTMLDivElement>(null);\n    /** DOM node of the handle container. */\n    const handleContainerRef = useRef<HTMLButtonElement>(null);\n    /** Current position as a percentage value (initially negative to sync bounds on mount). */\n    const internalPosition = useRef(position);\n    /** Whether user is currently dragging. */\n    const [isDragging, setIsDragging] = useState(false);\n    /** Whether the `transition` property can be applied. */\n    const [canTransition, setCanTransition] = useState(true);\n    /** Whether component has a `window` event binding. */\n    const hasWindowBinding = useRef(false);\n    /** Target container for pointer events. */\n    const [interactiveTarget, setInteractiveTarget] = useState<HTMLElement | null>();\n    /** The `position` value at *previous* render. */\n    const previousPosition = usePrevious(position);\n\n    /** Sync the internal position and trigger position change callback if defined. */\n    const updateInternalPosition = useCallback(\n      function updateInternal({ x, y, isOffset }: UpdateInternalPositionProps) {\n        const rootElement = rootContainerRef.current as HTMLDivElement;\n        const handleElement = handleContainerRef.current as HTMLButtonElement;\n        const clipElement = clipContainerRef.current as HTMLDivElement;\n        const { width, height, left, top } = rootElement.getBoundingClientRect();\n\n        // Early out when component has zero bounds.\n        if (width === 0 || height === 0) {\n          return;\n        }\n\n        const pixelPosition = portrait\n          ? isOffset\n            ? y - top - window.scrollY\n            : y\n          : isOffset\n          ? x - left - window.scrollX\n          : x;\n\n        /** Next position as percentage. */\n        const nextPosition = Math.min(\n          Math.max((pixelPosition / (portrait ? height : width)) * 100, 0),\n          100,\n        );\n\n        const zoomScale = portrait\n          ? height / (rootElement.offsetHeight || 1)\n          : width / (rootElement.offsetWidth || 1);\n\n        const boundsPaddingPercentage =\n          ((boundsPadding * zoomScale) / (portrait ? height : width)) * 100;\n\n        const nextPositionWithBoundsPadding = Math.min(\n          Math.max(nextPosition, boundsPaddingPercentage * zoomScale),\n          100 - boundsPaddingPercentage * zoomScale,\n        );\n\n        internalPosition.current = nextPosition;\n        handleElement.setAttribute('aria-valuenow', `${Math.round(internalPosition.current)}`);\n        handleElement.style.top = portrait ? `${nextPositionWithBoundsPadding}%` : '0';\n        handleElement.style.left = portrait ? '0' : `${nextPositionWithBoundsPadding}%`;\n        clipElement.style.clipPath = portrait\n          ? `inset(${nextPositionWithBoundsPadding}% 0 0 0)`\n          : `inset(0 0 0 ${nextPositionWithBoundsPadding}%)`;\n\n        if (onPositionChange) {\n          onPositionChange(internalPosition.current);\n        }\n      },\n      [boundsPadding, onPositionChange, portrait],\n    );\n\n    // Update internal position when other user controllable props change.\n    useEffect(() => {\n      const { width, height } = (\n        rootContainerRef.current as HTMLDivElement\n      ).getBoundingClientRect();\n\n      // Use current internal position if `position` hasn't changed.\n      const nextPosition = position === previousPosition ? internalPosition.current : position;\n\n      updateInternalPosition({\n        x: (width / 100) * nextPosition,\n        y: (height / 100) * nextPosition,\n      });\n    }, [boundsPadding, position, portrait, previousPosition, updateInternalPosition]);\n\n    /** Handle mouse/touch down. */\n    const handlePointerDown = useCallback(\n      (ev: PointerEvent) => {\n        ev.preventDefault();\n\n        // Only handle left mouse button (touch events also use 0).\n        if (disabled || ev.button !== 0) return;\n\n        updateInternalPosition({ isOffset: true, x: ev.pageX, y: ev.pageY });\n        setIsDragging(true);\n        setCanTransition(true);\n      },\n      [disabled, updateInternalPosition],\n    );\n\n    /** Handle mouse/touch move. */\n    const handlePointerMove = useCallback(\n      function moveCall(ev: PointerEvent) {\n        updateInternalPosition({ isOffset: true, x: ev.pageX, y: ev.pageY });\n        setCanTransition(false);\n      },\n      [updateInternalPosition],\n    );\n\n    /** Handle mouse/touch up. */\n    const handlePointerUp = useCallback(() => {\n      setIsDragging(false);\n      setCanTransition(true);\n    }, []);\n\n    /** Resync internal position on resize. */\n    const handleResize: (resizeProps: UseResizeObserverHandlerProps) => void = useCallback(\n      ({ width, height }) => {\n        const { width: scaledWidth, height: scaledHeight } = (\n          rootContainerRef.current as HTMLDivElement\n        ).getBoundingClientRect();\n\n        updateInternalPosition({\n          x: ((width / 100) * internalPosition.current * scaledWidth) / width,\n          y: ((height / 100) * internalPosition.current * scaledHeight) / height,\n        });\n      },\n      [updateInternalPosition],\n    );\n\n    /**\n     * Yo dawg, we heard you like handles, so we handled in your handle so you can handle while you\n     * handle.\n     */\n    const handleHandleClick = useCallback((ev: PointerEvent) => {\n      ev.preventDefault();\n      (handleContainerRef.current as HTMLButtonElement).focus();\n    }, []);\n\n    /** Handle keyboard movment. */\n    const handleKeydown = useCallback(\n      (ev: KeyboardEvent) => {\n        if (!Object.values(KeyboardEventKeys).includes(ev.key as KeyboardEventKeys)) {\n          return;\n        }\n\n        ev.preventDefault();\n        setCanTransition(true);\n\n        const { top, left } = (\n          handleContainerRef.current as HTMLButtonElement\n        ).getBoundingClientRect();\n\n        const { width, height } = (\n          rootContainerRef.current as HTMLDivElement\n        ).getBoundingClientRect();\n\n        const isPercentage = typeof keyboardIncrement === 'string';\n        const incrementPercentage = isPercentage\n          ? parseFloat(keyboardIncrement)\n          : (keyboardIncrement / width) * 100;\n\n        const isIncrement = portrait\n          ? ev.key === KeyboardEventKeys.ARROW_LEFT || ev.key === KeyboardEventKeys.ARROW_DOWN\n          : ev.key === KeyboardEventKeys.ARROW_RIGHT || ev.key === KeyboardEventKeys.ARROW_UP;\n\n        const nextPosition = Math.min(\n          Math.max(\n            isIncrement\n              ? internalPosition.current + incrementPercentage\n              : internalPosition.current - incrementPercentage,\n            0,\n          ),\n          100,\n        );\n\n        updateInternalPosition({\n          x: portrait ? left : (width * nextPosition) / 100,\n          y: portrait ? (height * nextPosition) / 100 : top,\n        });\n      },\n      [keyboardIncrement, portrait, updateInternalPosition],\n    );\n\n    // Set target container for pointer events.\n    useEffect(() => {\n      setInteractiveTarget(\n        onlyHandleDraggable ? handleContainerRef.current : rootContainerRef.current,\n      );\n    }, [onlyHandleDraggable]);\n\n    // Handle hover events on the container.\n    useEffect(() => {\n      const containerRef = rootContainerRef.current as HTMLDivElement;\n\n      const handlePointerLeave = (): void => {\n        if (isDragging) return;\n        handlePointerUp();\n      };\n\n      if (changePositionOnHover) {\n        containerRef.addEventListener('pointermove', handlePointerMove, EVENT_PASSIVE_PARAMS);\n        containerRef.addEventListener('pointerleave', handlePointerLeave, EVENT_PASSIVE_PARAMS);\n      }\n\n      return () => {\n        containerRef.removeEventListener('pointermove', handlePointerMove);\n        containerRef.removeEventListener('pointerleave', handlePointerLeave);\n      };\n    }, [changePositionOnHover, handlePointerMove, handlePointerUp, isDragging]);\n\n    // Allow drag outside of container while pointer is still down.\n    useEffect(() => {\n      if (isDragging && !hasWindowBinding.current) {\n        window.addEventListener('pointermove', handlePointerMove, EVENT_PASSIVE_PARAMS);\n        window.addEventListener('pointerup', handlePointerUp, EVENT_PASSIVE_PARAMS);\n        hasWindowBinding.current = true;\n      }\n\n      return (): void => {\n        if (hasWindowBinding.current) {\n          window.removeEventListener('pointermove', handlePointerMove);\n          window.removeEventListener('pointerup', handlePointerUp);\n          hasWindowBinding.current = false;\n        }\n      };\n    }, [handlePointerMove, handlePointerUp, isDragging]);\n\n    useImperativeHandle(\n      ref,\n      () => {\n        return {\n          rootContainer: rootContainerRef.current,\n          setPosition(nextPosition): void {\n            const { width, height } = (\n              rootContainerRef.current as HTMLDivElement\n            ).getBoundingClientRect();\n\n            updateInternalPosition({\n              x: (width / 100) * nextPosition,\n              y: (height / 100) * nextPosition,\n            });\n          },\n        };\n      },\n      [updateInternalPosition],\n    );\n\n    // Bind resize observer to container.\n    useResizeObserver(rootContainerRef, handleResize);\n\n    useEventListener(\n      'keydown',\n      handleKeydown,\n      handleContainerRef.current as HTMLButtonElement,\n      EVENT_CAPTURE_PARAMS,\n    );\n\n    useEventListener(\n      'click',\n      handleHandleClick,\n      handleContainerRef.current as HTMLButtonElement,\n      EVENT_CAPTURE_PARAMS,\n    );\n\n    useEventListener(\n      'pointerdown',\n      handlePointerDown,\n      interactiveTarget as HTMLDivElement,\n      EVENT_CAPTURE_PARAMS,\n    );\n\n    // Use custom handle if requested.\n    const Handle = handle || <ReactCompareSliderHandle disabled={disabled} portrait={portrait} />;\n    const appliedTransition = canTransition ? transition : undefined;\n\n    const rootStyle: CSSProperties = {\n      position: 'relative',\n      display: 'flex',\n      overflow: 'hidden',\n      cursor: isDragging ? (portrait ? 'ns-resize' : 'ew-resize') : undefined,\n      touchAction: 'none',\n      userSelect: 'none',\n      KhtmlUserSelect: 'none',\n      msUserSelect: 'none',\n      MozUserSelect: 'none',\n      WebkitUserSelect: 'none',\n      ...style,\n    };\n\n    return (\n      <div {...props} ref={rootContainerRef} style={rootStyle} data-rcs=\"root\">\n        {itemOne}\n        <ContainerClip ref={clipContainerRef} transition={appliedTransition}>\n          {itemTwo}\n        </ContainerClip>\n\n        <ContainerHandle\n          disabled={disabled}\n          portrait={portrait}\n          position={Math.round(internalPosition.current)}\n          ref={handleContainerRef}\n          transition={appliedTransition}\n        >\n          {Handle}\n        </ContainerHandle>\n      </div>\n    );\n  },\n);\n\nReactCompareSlider.displayName = 'ReactCompareSlider';\n","import React, { forwardRef } from 'react';\nimport type { CSSProperties, HTMLProps, ReactElement } from 'react';\n\nimport type { ReactCompareSliderCommonProps } from './types';\n\n/** Container for clipped item. */\nexport const ContainerClip = forwardRef<\n  HTMLDivElement,\n  HTMLProps<HTMLDivElement> & Pick<ReactCompareSliderCommonProps, 'transition'>\n>(({ transition, ...props }, ref): ReactElement => {\n  const style: CSSProperties = {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    width: '100%',\n    height: '100%',\n    transition: transition ? `clip-path ${transition}` : undefined,\n    userSelect: 'none',\n    willChange: 'clip-path, transition',\n    KhtmlUserSelect: 'none',\n    MozUserSelect: 'none',\n    WebkitUserSelect: 'none',\n  };\n\n  return <div {...props} style={style} data-rcs=\"clip-item\" ref={ref} />;\n});\n\nContainerClip.displayName = 'ContainerClip';\n\n/** Container to control the handle's position. */\nexport const ContainerHandle = forwardRef<\n  HTMLButtonElement,\n  HTMLProps<HTMLButtonElement> & ReactCompareSliderCommonProps\n>(({ children, disabled, portrait, position, transition }, ref): ReactElement => {\n  const targetAxis = portrait ? 'top' : 'left';\n\n  const style: CSSProperties = {\n    position: 'absolute',\n    top: 0,\n    width: portrait ? '100%' : undefined,\n    height: portrait ? undefined : '100%',\n    background: 'none',\n    border: 0,\n    padding: 0,\n    pointerEvents: 'all',\n    appearance: 'none',\n    WebkitAppearance: 'none',\n    MozAppearance: 'none',\n    outline: 0,\n    transform: portrait ? `translate3d(0, -50% ,0)` : `translate3d(-50%, 0, 0)`,\n    transition: transition ? `${targetAxis} ${transition}` : undefined,\n  };\n\n  return (\n    <button\n      ref={ref}\n      aria-orientation={portrait ? 'vertical' : 'horizontal'}\n      aria-valuemin={0}\n      aria-valuemax={100}\n      aria-valuenow={position}\n      data-rcs=\"handle-container\"\n      disabled={disabled}\n      role=\"slider\"\n      style={style}\n    >\n      {children}\n    </button>\n  );\n});\n\nContainerHandle.displayName = 'ThisHandleContainer';\n","import React from 'react';\nimport type { CSSProperties, FC, HtmlHTMLAttributes, ReactElement } from 'react';\n\nimport type { ReactCompareSliderCommonProps } from './types';\n\ninterface ThisArrowProps {\n  /** Whether to flip the arrow direction. */\n  flip?: boolean;\n}\n\nconst ThisArrow: FC<ThisArrowProps> = ({ flip }) => {\n  const style: CSSProperties = {\n    width: 0,\n    height: 0,\n    borderTop: '8px solid transparent',\n    borderRight: '10px solid',\n    borderBottom: '8px solid transparent',\n    transform: flip ? 'rotate(180deg)' : undefined,\n  };\n\n  return <div className=\"__rcs-handle-arrow\" style={style} />;\n};\n\n/** Props for `ReactCompareSliderHandle`. */\nexport interface ReactCompareSliderHandleProps\n  extends Pick<ReactCompareSliderCommonProps, 'disabled' | 'portrait'> {\n  /** Optional styles for handle the button. */\n  buttonStyle?: CSSProperties;\n  /** Optional styles for lines either side of the handle button. */\n  linesStyle?: CSSProperties;\n  /** Optional styles for the handle root. */\n  style?: CSSProperties;\n}\n\n/** Default `handle`. */\nexport const ReactCompareSliderHandle: FC<\n  ReactCompareSliderHandleProps & HtmlHTMLAttributes<HTMLDivElement>\n> = ({\n  className = '__rcs-handle-root',\n  disabled,\n  buttonStyle,\n  linesStyle,\n  portrait,\n  style,\n  ...props\n}): ReactElement => {\n  const _style: CSSProperties = {\n    display: 'flex',\n    flexDirection: portrait ? 'row' : 'column',\n    placeItems: 'center',\n    height: '100%',\n    cursor: disabled ? 'not-allowed' : portrait ? 'ns-resize' : 'ew-resize',\n    pointerEvents: 'none',\n    color: '#fff',\n    ...style,\n  };\n\n  const _linesStyle: CSSProperties = {\n    flexGrow: 1,\n    height: portrait ? 2 : '100%',\n    width: portrait ? '100%' : 2,\n    backgroundColor: 'currentColor',\n    pointerEvents: 'auto',\n    boxShadow: '0 0 4px rgba(0,0,0,.5)',\n    ...linesStyle,\n  };\n\n  const _buttonStyle: CSSProperties = {\n    display: 'grid',\n    gridAutoFlow: 'column',\n    gap: 8,\n    placeContent: 'center',\n    flexShrink: 0,\n    width: 56,\n    height: 56,\n    borderRadius: '50%',\n    borderStyle: 'solid',\n    borderWidth: 2,\n    pointerEvents: 'auto',\n    backdropFilter: 'blur(7px)',\n    WebkitBackdropFilter: 'blur(7px)', // For Safari.\n    backgroundColor: 'rgba(0, 0, 0, 0.125)',\n    boxShadow: '0 0 4px rgba(0,0,0,.35)',\n    transform: portrait ? 'rotate(90deg)' : undefined,\n    ...buttonStyle,\n  };\n\n  return (\n    <div\n      {...props}\n      aria-label={props['aria-label'] || 'Drag to move'}\n      className={className}\n      style={_style}\n    >\n      <div className=\"__rcs-handle-line\" style={_linesStyle} />\n      <div className=\"__rcs-handle-button\" style={_buttonStyle}>\n        <ThisArrow />\n        <ThisArrow flip />\n      </div>\n      <div className=\"__rcs-handle-line\" style={_linesStyle} />\n    </div>\n  );\n};\n","import type { CSSProperties, RefObject } from 'react';\nimport { useCallback, useEffect, useLayoutEffect, useRef } from 'react';\n\n/** Keyboard `key` events to trigger slider movement. */\nexport enum KeyboardEventKeys {\n  ARROW_LEFT = 'ArrowLeft',\n  ARROW_RIGHT = 'ArrowRight',\n  ARROW_UP = 'ArrowUp',\n  ARROW_DOWN = 'ArrowDown',\n}\n\n/**\n * Stand-alone CSS utility to make replaced elements (`img`, `video`, etc.) fit their container.\n */\nexport const styleFitContainer = ({\n  boxSizing = 'border-box',\n  objectFit = 'cover',\n  objectPosition = 'center center',\n  ...props\n}: CSSProperties = {}): CSSProperties => ({\n  display: 'block',\n  width: '100%',\n  height: '100%',\n  maxWidth: '100%',\n  boxSizing,\n  objectFit,\n  objectPosition,\n  ...props,\n});\n\n/** Store the previous supplied value. */\nexport const usePrevious = <T>(value: T): T => {\n  const ref = useRef<T>(value);\n\n  useEffect(() => {\n    ref.current = value;\n  });\n\n  return ref.current;\n};\n\n/**\n * Event listener binding hook.\n * @param eventName      - Event to bind to.\n * @param handler        - Callback handler.\n * @param element        - Element to bind to.\n * @param handlerOptions - Event handler options.\n */\nexport const useEventListener = (\n  eventName: EventListener['name'],\n  handler: EventListener['caller'],\n  element: EventTarget,\n  handlerOptions: AddEventListenerOptions,\n): void => {\n  const savedHandler = useRef<EventListener['caller']>();\n\n  useEffect(() => {\n    savedHandler.current = handler;\n  }, [handler]);\n\n  useEffect(() => {\n    // Make sure element supports addEventListener.\n    if (!(element && element.addEventListener)) return;\n\n    // Create event listener that calls handler function stored in ref.\n    const eventListener: EventListener = (event) =>\n      savedHandler.current && savedHandler.current(event);\n\n    element.addEventListener(eventName, eventListener, handlerOptions);\n\n    return (): void => {\n      element.removeEventListener(eventName, eventListener, handlerOptions);\n    };\n  }, [eventName, element, handlerOptions]);\n};\n\n/**\n * Conditionally use `useLayoutEffect` for client *or* `useEffect` for SSR.\n * @see https://github.com/reduxjs/react-redux/blob/89a86805f2fcf9e8fbd2d1dae345ec791de4a71f/src/utils/useIsomorphicLayoutEffect.ts\n */\nconst useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' &&\n  typeof window.document !== 'undefined' &&\n  typeof window.document.createElement !== 'undefined'\n    ? useLayoutEffect\n    : useEffect;\n\n/** Params passed to `useResizeObserver` `handler` function. */\nexport type UseResizeObserverHandlerProps = DOMRect;\n\n/**\n * Bind resize observer callback to element.\n * @param ref       - Element to bind to.\n * @param handler   - Callback for handling entry's bounding rect.\n */\nexport const useResizeObserver = (\n  ref: RefObject<Element>,\n  handler: (entry: UseResizeObserverHandlerProps) => void,\n): void => {\n  const observer = useRef<ResizeObserver>();\n\n  const observe = useCallback(() => {\n    if (ref.current && observer.current) observer.current.observe(ref.current);\n  }, [ref]);\n\n  // Bind/rebind observer when `handler` changes.\n  useIsomorphicLayoutEffect(() => {\n    observer.current = new ResizeObserver(([entry]) => handler(entry!.contentRect));\n    observe();\n\n    return (): void => {\n      if (observer.current) observer.current.disconnect();\n    };\n  }, [handler, observe]);\n};\n","import React from 'react';\nimport type { CSSProperties, FC, ImgHTMLAttributes, ReactElement } from 'react';\n\nimport { styleFitContainer } from './utils';\n\n/** Props for `ReactCompareSliderImage`. */\nexport type ReactCompareSliderImageProps = ImgHTMLAttributes<HTMLImageElement>;\n\n/** `Img` element with defaults from `styleFitContainer` applied. */\nexport const ReactCompareSliderImage: FC<ReactCompareSliderImageProps> = ({\n  style,\n  ...props\n}): ReactElement => {\n  const rootStyle: CSSProperties = styleFitContainer(style);\n\n  return <img {...props} style={rootStyle} data-rcs=\"image\" />;\n};\n","import type { MutableRefObject } from 'react';\nimport { useRef } from 'react';\n\nimport type { UseReactCompareSliderRefReturn } from './types';\n\n/**\n * Control the position and access or modify the DOM elements of the slider.\n */\nexport const useReactCompareSliderRef = (): MutableRefObject<UseReactCompareSliderRefReturn> =>\n  useRef<UseReactCompareSliderRefReturn>({\n    rootContainer: null,\n    setPosition: () =>\n      // eslint-disable-next-line no-console\n      console.warn(\n        '[react-compare-slider] `setPosition` cannot be used until the component has mounted.',\n      ),\n  });\n"],"mappings":"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","names":["forwardRef","useCallback","useEffect","useImperativeHandle","useRef","useState","forwardRef","jsx","ContainerClip","transition","props","ref","style","ContainerHandle","children","disabled","portrait","position","jsx","jsxs","ThisArrow","flip","ReactCompareSliderHandle","className","disabled","buttonStyle","linesStyle","portrait","style","props","_style","_linesStyle","_buttonStyle","useCallback","useEffect","useLayoutEffect","useRef","KeyboardEventKeys","styleFitContainer","boxSizing","objectFit","objectPosition","props","usePrevious","value","ref","useEventListener","eventName","handler","element","handlerOptions","savedHandler","eventListener","event","useIsomorphicLayoutEffect","useResizeObserver","observer","observe","entry","jsx","jsxs","EVENT_PASSIVE_PARAMS","EVENT_CAPTURE_PARAMS","ReactCompareSlider","forwardRef","disabled","handle","itemOne","itemTwo","onlyHandleDraggable","onPositionChange","portrait","position","boundsPadding","changePositionOnHover","keyboardIncrement","style","transition","props","ref","rootContainerRef","useRef","clipContainerRef","handleContainerRef","internalPosition","isDragging","setIsDragging","useState","canTransition","setCanTransition","hasWindowBinding","interactiveTarget","setInteractiveTarget","previousPosition","usePrevious","updateInternalPosition","useCallback","x","y","isOffset","rootElement","handleElement","clipElement","width","height","left","top","pixelPosition","nextPosition","zoomScale","boundsPaddingPercentage","nextPositionWithBoundsPadding","useEffect","handlePointerDown","ev","handlePointerMove","handlePointerUp","handleResize","scaledWidth","scaledHeight","handleHandleClick","handleKeydown","KeyboardEventKeys","incrementPercentage","isIncrement","containerRef","handlePointerLeave","useImperativeHandle","useResizeObserver","useEventListener","Handle","ReactCompareSliderHandle","appliedTransition","rootStyle","ContainerClip","ContainerHandle","jsx","ReactCompareSliderImage","style","props","rootStyle","styleFitContainer","useRef","useReactCompareSliderRef"]}